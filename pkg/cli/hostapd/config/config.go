package config

import (
	"bufio"
	"errors"
	"fmt"
	"os"
	"strings"
	"time"
)

type Map = map[string]string
type Config struct {
	configFile string
	options    Map
}

// Validates configuration and writes it
func (c *Config) Write() error {
	if err := c.Validate(); err != nil {
		return fmt.Errorf("validation failed: %s", err)
	}

	return writeConfiguration(c.configFile, c.options)
}

func (c *Config) Validate() error {
	var err error

	for k, v := range c.options {
		if strings.Contains(k, " ") {
			errors.Join(err, fmt.Errorf("invalid key %q", k))
		}
		if e := containsSpecialRuns(v); e != nil {
			errors.Join(err, fmt.Errorf("invalid value fro key %q: %s", k, e))
		}
	}

	return nil
}

func FromFile(configFile string) (*Config, error) {
	opts, err := parseConfiguration(configFile)
	if err != nil {
		return nil, fmt.Errorf("failed parse configuration: %s", err)
	}

	conf := &Config{
		configFile: configFile,
		options:    opts,
	}
	return conf, nil
}

func parseConfiguration(config string) (map[string]string, error) {
	read, err := os.Open(config)
	if err != nil {
		return nil, fmt.Errorf("failed open config file %q: %s", config, err)
	}
	defer read.Close()

	result := map[string]string{}

	scan := bufio.NewScanner(read)
	lineIndex := 0
	for scan.Scan() {
		lineIndex++
		line := scan.Text()
		if line == "" {
			continue
		}
		if line[0] == '#' {
			continue
		}
		words := strings.Split(line, "=")
		if len(words) != 2 {
			if len(words) == 1 {
				return nil, fmt.Errorf("invalid line %d %q, there no value specified", lineIndex, line)
			} else {
				return nil, fmt.Errorf("invalid line %d %q, there more than one value specified", lineIndex, line)
			}
		}

		result[words[0]] = words[1]

	}

	return result, nil
}

func writeConfiguration(config string, options map[string]string) error {
	write, err := os.Create(config)
	if err != nil {
		return fmt.Errorf("failed open or create config file %q: %s", config, err)
	}
	defer write.Close()

	write.WriteString("# Generated by zarinit-server\n")
	fmt.Fprintf(write, "# Generated on %s\n", time.Now().Format(time.RFC3339))
	write.WriteString("# Generator written by Katy248\n")
	write.WriteString("#\n")
	write.WriteString("#\n")
	write.WriteString("# You've got to pay!\n")
	write.WriteString("# ...\n")
	write.WriteString("# Back off get out of the way too late\n")
	write.WriteString("# Do you feel pity\n")
	write.WriteString("# You're standing alone\n")
	write.WriteString("# When it falling apart, falling apart\n")
	write.WriteString("#\n")
	write.WriteString("# \t\t-- Combichrist - Falling apart\n")
	write.WriteString("\n\n")

	for key, value := range options {
		_, err := fmt.Fprintf(write, "%s=%s\n", key, value)
		if err != nil {
			return fmt.Errorf("failed write config file %q: %s", config, err)
		}
	}

	return nil
}

func (c *Config) getOption(key string) string {
	return c.options[key]
}

func (c *Config) setOption(key, value string) {
	c.options[key] = value
}

func (c *Config) deleteOption(key string) {
	delete(c.options, key)
}
